---
title: 基于图块的渲染(WIP)
date: 2020-09-14 17:23:39
tags: 
- GPU
- TBR
---

# 概述
* 与桌面GPU可以极端追求性能不同, 移动端GPU必须在性能与电量之间进行平衡
* 电量开销最大的是内存带宽
* 移动设备没有显存, 与CPU共用一块内存
* 由于空间限制, 片上空间非常有限
* 解决方案就是在片上放一个高速的图块缓冲(Tile Buffer), 按照图块来进行渲染, 渲染完成后将图块缓冲的内容写入到片外的帧缓冲(Frame Buffer)

# 基本流程
* 经过几何处理之后, 将各个图块的几何信息保存到片外的内存, 这块数据叫做帧数据(frame data)
* 在片元处理阶段, 从片外内存读取帧数据, 然后以图块为单位对图块缓冲进行读写, 整个图块处理完毕之后, 把颜色写入到帧缓冲中
* 只要帧数据较小, 这个优化就是成立的, 但如果模型过于细分, 这就变成了一个劣化

# 理解帧数据
* 渲染的内容并不是写入到帧缓冲, 而是生成帧数据
* glClear操作对于帧缓冲是昂贵的, 但对于帧数据只是简单释放已有数据, 代价非常低

# 帧缓冲刷新 (Flush)
* 有些操作会造成帧缓冲刷新, 这样会中断分箱操作, 立刻进入到着色阶段, 然后再执行一次全新的渲染流程
* 帧数据过大会造成帧缓冲强制刷新, 并且会备份所有的内容用于刷新后继续执行, 这是非常非常消耗带宽的

# 迟滞 (Latency)
* 如果一块数据每帧都有修改, 那么需要双缓冲

# Early Z
* 如果一个像素被多次描绘, IMR模式会有两个消耗: 着色消耗和带宽消耗, TBR模式只有着色消耗, 没有带宽消耗
* Early Z对IMR和TBR都有效, 但是代价不同, IMR模式下, 对深度缓冲的访问会翻倍, 所以带宽消耗会增加; TBR模式下, 深度缓冲在片上, 消耗非常小, 但是帧数据会翻倍. 所以在桌面端上Early Z无效, 在移动端可能是有效的.
* PowerVR的GPU含有HSR单元, 所以不需要花费CPU算力进行深度排序

# 颜色混合
* 颜色混合需要对当前像素的颜色进行读/写, 对于IMR是一个开销很大的操作, 但是对于TBR, 读写都在片上, 是一个开销很小的操作
* 颜色混合本身会带来一个消耗, 透明物体会令被遮挡住的物体无法被剔除

# 多重采样
* 4次多重采样在IMR模式会带来4倍的带宽开销, 但是TBR模式下只会把最终结果写入到帧缓冲, 所以不会带来多余的带宽消耗
* 图块缩小会带来一个很小的性能下降
* 开启多重采样会使边缘的剔除失效, 可能造成10%的性能下降


